1：无信息搜索策略：
无信息搜索算法不提供有关某个状态与目标状态的接近程度的任何线索
1.1：广度优先搜索：
所有动作代价相同时，采用广度优先搜索
可以调用best first search用来广度搜索。其中f(n)为节点的深度，
可以进行早期目标测试，在生成节点后立即检查该节点是否为一个解。且在生成深度d的节点时，已经生成了深度为d-1的节点
时间复杂度和空间复杂度为O(b^d)其中d为dimension

1.2 dijkstra算法或一致代价搜索。
动作具有不同的代价时，采用最佳优先搜索。该算法调用best first search，评价函数为 path-cost
一致代价搜索会按照代价递增顺序系统地考虑所有路径，而不会沿单一无线搜索。

1.3 深度优先搜索与内存问题
深度优先搜索总是优先扩展边界中最深的节点。可以通过调用best first search 实现。深度优先算法对内存需求小
不保留reached表。且边界集小。
回溯搜索为深度优先搜索的一种变体。使用内存更小。

1.4深度受限，和迭代加深搜索。
为了避免陷入无限路径，采用深度受限算法。可以通过实际情况，对算法选择一个适合的深度。
迭代加深搜索

1.5双向搜索
从正向和反向同时向目标搜索。原因时复杂度减少很多。

1.6无信息搜索算法对比
完备性：深度优先和深度受限不行
代价最优：深度优先和深度受限不行
时间复杂度和空间负责都。深度优先和深度受限好一些。

2 有信息（启发式）搜索策略
可以通过有效的信息进行对目标信息进行估计。
h(n)=从节点n的状态到目标状态的最小代价路径的代价估计值

2.1贪心最佳优先搜索：
首先扩展h(n)最小的节点
例如可以取直线距离作为启发式函数
贪心只是当前最好，但是全局未必。

2.2A搜索
评价函数为
f(n)=g(n)+h(n)
其中g(n)是从初始状态到节点n的路径代价，h(n)是从节点n到一个状态最短路径的价值估计
我们一致认为一致启发式函数的A搜索时效率最优
A搜索可能扩展起来时指数型的，此时不适合

2.3搜索等值线
对搜索进行可视化的方法时绘制等值线。

2.4满意搜索：不可容许的启发式函数与加权A搜索
采用了加权A搜索
f（n)=g(n)+W*h(n)

搜索的统一表达:
a搜索： g（n）+h（n）
一致代价搜索：g(n)
贪心最佳优先搜索：h(n)
加权a搜索：g（n）+W*h（n）

2.5内存受限搜索
内存分为frontier 状态和reached状态。边界状态被存储在两个位置：边界中的一个节点和已达状态表中的一个表项
frontier要比 reached小很多
有可能是：当我们证明不再需要某些状态时，可以讲他们从reached中删除。可以用引用计数，进行删除。
束搜索：对边界的大小进行限制。
迭代加深a搜索，有a优点，又不要求内存保留所有已达状态，代价多次访问某些状态。
递归最优搜索：RBFS比IDA更高效，但是存在重复生成大量节点问题。
如果启发式h(n)可以容许，那么RBFS最优。取决于hn的准确性
MA memory bounded A 和 SMA simplifed memory bounded A。不断扩展最优节点，知道内存被填满。
本书代码库有完整SMA。扩展最优节点，删除最拉节点。

2.6双向启发式搜索。
双向启发中也可以使用a的表达来进行搜索。
双向搜索有时比但搜索更有效，但是有时候不是。如果有个很好启发式函数，那么a搜索会生成专注于目标的搜索等值线
双向搜索此时加成不大。

